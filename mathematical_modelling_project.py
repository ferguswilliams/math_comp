# -*- coding: utf-8 -*-
"""
Created on Tue Feb 25 12:47:15 2020

@author: Fergus
"""
print('1. - Single Species Model' )
print('')
print('Part 1')

#need to import the relevant python packages
from numpy import*
from matplotlib.pylab import*

#can now define the function of interest dx/dt=F(x) which will be plotted
def F(x):
    return 0.01- 0.4*x+(x**2)/(1+x**2)
#can now define an array of x values over the interval (0 - 2.2), with 100 data points.
x=linspace(0,2.2,100)
#define an array to store the function F(x) values
f=zeros(100)
#can use a for loop to generate function values and assign them to the array f
for i in range(100):
    f[i]=F(x[i])
#these array values can now be plotted to produce the graph dx/dt vs x
figure(figsize=(8,6))
plot(x,f)
title('Graph of dx/dt as a function of x')
xlabel('x')
ylabel('dx/dt')
#can add gridlines to make identification of roots easier
plt.grid(True)
plt.show()

print('From inspection of this graph we observe three positive roots. An approximation of x=0 would be appropriate for the first root. x= 0.5 would be suitable for the second root. An approximation of x=2 seems appropriate for the third.')
print('')

#now define a general function that employs the newton raphson method to calculate a root; based on an inital estimate x, a function f and differential dfdx
def NR(x,f,dfdx):
#this funcion employs a while loop to iterate the newton raphson method until we have agreement of approximations to 4d.p.
#must initially define the difference between successive x values as being greater than 0.00005 in order for the loop to work.
    dif=1
#define the initial iteration number n=0    
    n=0
#define the condition for while loop, for agreement to 4d.p. we need the difference between successive approximations to be less than 0.00005
    while dif>=0.00005:
#generate the next approximation using the newton raphson formula        
         xnext=x-(f(x))/(dfdx(x))
#define the difference between successive approximations, this must be absolute as the while loop will stop if negative differences are generated.         
         dif=abs(xnext-x)
#increase the iteration number 
         n=n+1
#print the relevant parameters requested, iteration number (n), approximation (xnext), and difference (xnext-x)         
         print('n =', n,'xn =', xnext,'xn-x(n-1) =',xnext-x)
#redefine the input approximation for next iterative step         
         x=xnext
#return a print statement giving the value of root to 4d.p.             
    return print('The value of the root correct to 4d.p. is'  , round(x,4) )
#we now have a general newton raphson root calculator, which requires the specified input function f and dfdx.
# F(x) has been previously defined , so only the differential of F(x) needs to be defined
def Fdash(x):
    return 2*x/((1+x**2)**2) - 0.4
#printing the inital approximation for the first root
print('Applying the Newton Raphson solver to identify the first root we have:' )
print('n = 0','xn = 0')
#produce output of the Newton Raphson function for an initial estimate of x=0 for the function F(x)
NR(0,F,Fdash)
print('')
#printing the inital approximation for the second root
print('Applying the Newton Raphson solver to identify the second root we have:' )
print('n = 0','xn = 0.5')
#produce output of the Newton Raphson function for an initial estimate of x=0.5 for the function F(x)
NR(0.5,F,Fdash)
print('')
#printing the inital approximation for the third root
print('Applying the Newton Raphson solver to identify the third root we have:' )
print('n = 0','xn = 2')
#produce output of the Newton Raphson function for an initial estimate of x=2 for the function F(x)
NR(2,F,Fdash)
print('')
print('Part 2')
#can define a general Runge Kutta 4 function that produces a graphical solution to an ODE
#the functions takes arguments of initial conditions x and t, a time step of h, calculating n steps , for a function dx/dt = f(x,t)
def RK4(x,t,h,n,f):
#create arrays to store the subsequent x and t values generated by the RK4 method. 
    xstore=[]
    tstore=[]
#add the initial conditions for x and t to arrays
    xstore.append(x)
    tstore.append(t)
#now define a for loop that performs n iterations of the RK4 method using the time step h
    for i in range(n):
#define intermediate parameters for the method        
        k1=h*f(x,t)
        k2=h*f(x+k1/2,t+h/2)
        k3=h*f(x+k2/2,t + h/2)
        k4=h*f(x+k3,t+h)
#generate the next x value using method
        x=x+(1/6)*(k1+2*k2+2*k3+k4)
#generate the next t value by adding the time step        
        t=t+h
#add the newly generated x and t value to the appropriate arrays.        
        xstore.append(x)
        tstore.append(t)
#return a plot of the solution 
    return plot(tstore,xstore)
#we now have a general function that will numerically solve an ODE and produce a graphical solution
#need to define the function F(x) in the question as a function of x and t for the ODE solver to work
def f(x,t):
    return 0.01-0.4*x+(x**2)/(1+x**2)
#produce the output plots of the RK4 function for the specified initial conditions, a time step of h=0.05 and 900 steps has been selected to ensure long term behaviour is observed
figure(figsize=(8,6))
RK4(0.45,0,0.05,900,f)
RK4(0.5,0,0.05,900,f)
xlabel('t')
ylabel('x')
plt.grid()
title('Solutions to the ODE showing x as a function of t')
plt.show()

#Part 2 - Competing Species Model
print('2. Competing Species Model')
print('')
print('Part 1')
#in order to find an appropriate initial estimate for the solution to this system of equations, we can rearrange each equation to express y explicitly as a function of x.
#plotting a graph of y vs x for the two functions, will indicate the root as the intersection of the two curves
#we can now define the two functions y=g(x) and y=f(x)
def f(x):
    return 10*log((1-x)*10)
def g(x):
    return 1-0.2*e**(0.3*x)
#now define arrays to store x values, and the corresponding f(x) and g(x) function values
xstore=[]
fstore=[]
gstore=[]
#define the lower limit of the x value we wish to plot
x=0
#add initial x value and corresponding function values to appropriate arrays
xstore.append(x)
fstore.append(f(x))
gstore.append(g(x))
#can define a suitable x step
h=0.01
# define a for loop that iteratively increases the x value and generates corresponding function values
for i in range(95):
#generate next x value by adding x step    
    x=x+h
#add x value and corresponding function values to appropriate arrays    
    xstore.append(x)
    fstore.append(f(x))
    gstore.append(g(x))
#produce plot of y=f(x) and y=g(x)
figure(figsize=(8,6))
plot(xstore,fstore, label='f(x)')    
plot(xstore,gstore, label='g(x)')
xlabel('x')
ylabel('y')
title('Plot showing the solution of the system of equations')
legend()
plt.show()

print('The two functions intersect at roughly x,y = 0.9,1 so these are suitable initial estimates for the 2D Newton Raphson method.')
print('')
#can now define a general 2D newton raphson function , that takes an inital estimate x and y, applying the NR formula using functions f and g , and the neccessary partial differentials.
def NR2D(x,y,f,g,dfdx,dfdy,dgdx,dgdy):
# again a while loop will be used to find the root correct to 4d.p., therefore need to define difference between successive x and y estimates which must be greater than 0.00005
    dify=1
    difx=1
#define condition for while loop, if the difference between successive estimates of y or x is greater than 0.00005 then iterations will continue
    while difx or dify >= 0.00005:
#define the determinant of the jacobian matrix for NR 2D method        
         det=dfdx(x,y)*dgdy(x,y) - dfdy(x,y)*dgdx(x,y)
#produce the next estimates for x and y using the Newton Raphson 2D formula         
         xnext=x - (1/det)*(dgdy(x,y)*f(x,y) - dfdy(x,y)*g(x,y))
         ynext=y - (1/det)*((-dgdx(x,y))*f(x,y) + dfdx(x,y)*g(x,y))
#redefine the difference between successive values, taking the absolute value since negative values will stop the loop          
         difx=abs(xnext-x)
         dify=abs(ynext-y)
#redefine the input estimate x and y, for the next iteration         
         x = xnext
         y = ynext
#return a statement giving the values correct to 4d.p.       
    return print('The solution to the system of equations, and final steady state of the system correct to 4d.p. is (x , y) = ( ',round(x,4),',',round(y,4),')')
# we now have a function that applies the Newton Raphson 2D method for any abitrary f(x) and g(x) calculating the root to 4d.p.
#can now define the functions and the required partial differentials for the system of equations, of interest
def dfdx(x,y):
    return -1
def dfdy(x,y):
    return -0.01*exp(0.1*y)
def dgdx(x,y):
    return -0.06*exp(0.3*x)
def dgdy(x,y):
    return -1
def f(x,y):
    return 1- x -0.1*exp(0.1*y)
def g(x,y):
    return 1-y-0.2*exp(0.3*x)
#produce the output of the Newton raphson 2d functions acting on the specified system of equations for the the inital estimate x,y=0.9,1
NR2D(0.9,1,f,g,dfdx,dfdy,dgdx,dgdy)
print('')
#Competing Species Model - Part 2.
print('')
print('Part 2')
#can define a general function that solves a system of ODES using the RK4 method. Based on initial conditons x ,y,t ; a time step of h, for n steps and functions of dx/dt=f and dy/dt=g.
def RK4XY(x,y,t,h,n,f,g):
#can arrange the functions that describe dx/dt and dy/dt in an array for conciseness
    def m(x,y,t):
        return array([f(x,y,t),g(x,y,t)])
#create arrays for storing x and y values generated by the RK4 method    
    xstore=[]
    ystore=[]
#add the initial conditions for x and y to appropriate arrays
    xstore.append(x)
    ystore.append(y)
#define a for loop that iterates the RK4 method for n successive steps
    for i in range(n):
#define intermediate arrays using the previously defined vector function        
        k1=h*m(x,y,t)
        k2=h*m(x+k1[0]/2,y+k1[1]/2,t+h/2)
        k3=h*m(x+k2[0]/2,y+k2[1]/2,t+h/2)
        k4=h*m(x+k3[0],y+k3[1],t)
#generate the next x and y values as an array         
        [x,y]=[x,y]+(1/6)*(k1+2*k2+2*k3+k4)
#generate the next t value by adding the time step      
        t=t+h
#add the x and y values to appropriate arrays        
        xstore.append(x)
        ystore.append(y)
#return a plot of x and y values hence providing a graphical solution to the ode     
    return plot(xstore,ystore,'k',linewidth=0.5)
#we now have a general function that solves a system of ODEs and produce a plot of the solution
#can now define the functions describing the system of ODE's
def f(x,y,t):
    return x*(1-x-0.1*exp(0.1*y))
def g(x,y,t):
    return y*(1-y-0.2*exp(0.3*x))
#can now apply the RK4 function for different initial conditions to plot solutions for various trajectories
#the inital conditions for the function can be easily changed using a for loop
figure(figsize=(12,10))
#define a for loop that iteratively alters the initial conditions to build up plots for the phase portrait
for i in range(21):
#have selected the time step h = 0.05 and n=300 to ensure long term behaviour is observed
#plot solutions by changing the initial conditions of x in regular increments, whilst holding y small and fixed, i.e. bottom edge of phase portrait
    RK4XY(i/10,0.02,0,0.05,300,f,g)
#plot solutions by changing the inital y condition in regular increments whilst holding x small and fixed,i.e. left edge of phase portrait
    RK4XY(0.02,i/10,0,0.05,300,f,g)
#plot solutions by changing x initial conditions by regular increments, whilst holding y large and fixed i.e. top edge of phase portrait
    RK4XY(i/10,2,0,0.05,300,f,g)
#plot solutions by changing inital y conditions, whilst holding x fixed and large , i.e. right edge of phase portrait
    RK4XY(2,i/10,0,0.05,300,f,g)
#to generate solutions around the steady state at 0,0 can parametrise x and y conditions as a circle in terms of cosine and sine, and change angle between 0 and pi/2
    RK4XY(0.01*cos(i*pi/40),0.01*sin(i*pi/40),0,0.05,300,f,g)
#plot steady states as dots
plot(0.8923,0.7386,'ro')
plot(0,0,'ro')
plot(0,0.8,'ro')
plot(0.9,0,'ro') 
title('Phase Plane Plot for the System of ODEs')   
xlabel('x')
ylabel('y')


















   